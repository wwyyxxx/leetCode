Android面试题整理

View：
MeasureSpec 和LayoutParams关系
    View在测量的时候,系统会将LayoutParams在父容器的约束下转换成对应的MeasureSpec，,然后根据这个MeasureSpec来确定View测量之后的高和宽
    DecorView的MeasureSpec是由窗口的尺寸和DecorView其自身的LayoutParams来共同决定的.
    普通View的MeasureSpec是由父容器的MeasureSpec和普通View自身的LayoutParams来共同决定的.

MeasureSpec是什么？ 
    MeasureSpec是View中的内部类，基本都是二进制运算。由于int是32位的，用高两位表示mode，低30位表示size，MODE_SHIFT = 30的作用是移位
        UNSPECIFIED：不对View大小做限制，系统使用
        EXACTLY：确切的大小
        AT_MOST：大小不可超过某数值

MeasureSpec创建规则
    UNSPECIFIED
        xxdp: EXACTLY
        match_parent: UNSPECIFIED
        wrap_content: UNSPECIFIED
    EXACTLY
        xxdp: EXACTLY
        match_parent: EXACTLY
        wrap_content: AT_MOST
    AT_MOST
        xxdp: EXACTLY
        match_parent: AT_MOST
        wrap_content: AT_MOST

getMeasureWidth与getWidth的区别
    getMeasureWidth: 在measure()过程结束后就可以获取到对应的值 通过setMeasuredDimension()方法来进行设置的.
    getWidth: 在layout()过程结束后才能获取到 通过视图右边的坐标减去左边的坐标计算出来的.

点击事件:
move--处理事件
1.先看是否拦截后自己处理（即不分发下去）
2.分发下去：
	直接由down事件确定的view处理

recycleView:
    当我们使用局部刷新，payload 不为空 ，这个时候，如果 ViewHolder 需要更新，它的 更新标识 的确会被加入，但是同时canReuseUpdatedViewHolder() 也会返回 true ，所以，这个时候 ViewHolder 不会被添加到 mChangedScrap 集合中，而是加入 mAttachedScrap 集合中，。
所以，当你使用局部刷新时，前后都是同一个 ViewHolder ，如果位置没有变化，就不会执行动画效果；而当你不使用局部刷新时，使用的不是同一个 ViewHolder ，不管位置是否变化，都会执行相关动画，所以你看到的 itemView 会闪烁一下。当我们多次调用 notifyItemChange() 方法时，也不会多次触发 requestLayout() 和回调 bindViewHolder()

复用：从集合中去获取
怎么从集合中去获取：tryGetViewHolderForPositionByDeadline，分几种情况去获取ViewHolder
    1. getChangedScrapViewForPosition -- mChangeScrap 与动画相关
    2. getScrapOrHiddenOrCachedHolderForPosition  -- mAttachedScrap 、mCachedViews 
    3. getScrapOrCachedViewForId  -- mAttachedScrap 、mCachedViews (ViewType,itemid)
    4. mViewCacheExtension.getViewForPositionAndType -- 自定义缓存
    5. getRecycledViewPool().getRecycledView -- 从缓冲池里面获取

ViewHolder -- 包装View的 --- ItemView

当没有缓存的时候？？--- mAdapter.createViewHolder --》 onCreateViewHolder

多级缓存的目的 -- 为了性能

创建ViewHolder 后 绑定： tryBindViewHolderByDeadline--》 mAdapter.bindViewHolder--》onBindViewHolder

回收（缓存）机制：看这一个情况--- viewHolder

去查找缓存和复用的一种情况:
    入口：复用：RecyclerView.onLayout --> dispatchLayout --》 dispatchLayoutStep2 --》 onLayoutChildren --》 fill
    缓存：fill -->recycleByLayoutState-->recycleViewsFromStart --> recycleChildren
    --> removeAndRecycleViewAt --> recycler.recycleView 
    --> recycler.recycleViewHolderInternal(viewHolder); -- 处理 CacheView 、RecyclerViewPool 的缓存


Handler:
Handler通过sendMessage()将Message发送到MessageQueue中，这是存消息的过程；
Looper通过调用MessageQueue的next()方法取出Message对象，由于这是一个时间优先级的队列，所以会取到队头的Message，然后拿当前时间去跟它的执行时间，也就是when参数去对比，如果时间还没到，就先不会执行；

1：一个线程有几个 Handler？
    多个

2：一个线程有几个 Looper？如何保证？
    一个，sThreadLocal.set(new Looper(quitAllowed))
    ThreadLocal:一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储之后，只有在指定线程中可以获取到存储的数据，对于其他的线程来说则无法获取到数据

3：Handler内存泄漏原因？ 为什么其他的内部类没有说过有这个问题？
    内部类持有外部的引用。
    因此Message持有Handler的引用，Handler又持有Activity的引用，所以在Message处理完之前，如果Activity被销毁了，就会造成内存泄漏。
4：为何主线程可以new Handler？如果想要在子线程中new Handler 要做些什么准备？
    因为在ActivityThread中的main()已经对Looper进行了prepar()操作，所以可以直接在主线程new Handler。
    如果想在子线程中new Handler，则需要先手动调用Looper的prepare()方法初始化Looper，再调用Looper的loop()方法使Looper运转。

5：子线程中维护的Looper，消息队列无消息的时候的处理方案是什么？有什么用？
    如果不处理的话，会阻塞线程，处理方案是调用Looper的quitSafely()；
    这个方法会调用MessageQueue的quit()方法，清空所有的Message，并调用nativeWake()方法唤醒之前被阻塞的nativePollOnce()，使得方法next()方法中的for循环继续执行，接下来发现Message为null后就会结束循环，Looper结束。如此便可以释放内存和线程。

6：既然可以存在多个 Handler 往 MessageQueue 中添加数据（发消息时各个Handler可能处于不同线程），那它内部是如何确保线程安全的？
    添加消息的方法enqueueMessage()中有synchronize修饰，取消息的方法next()中也有synchronize修饰。
    由于上述的加锁操作，所以时间不能保证完全准确。
7：我们使用 Message 时应该如何创建它？
    使用Message的obtain()方法创建，直接new出来容易造成内存抖动。
    内存抖动是由于频繁new对象，gc频繁回收导致，而且由于可能被别的地方持有导致无法及时回收所以会导致内存占用越来越高。
    使用obtain()对内存复用，可以避免内存抖动的发生。其内部维护了一个Message池，其是一个链表结构，当调用obtain()的时候会复用表头的Message，然后会指向下一个。如果表头没有可复用的message则会创建一个新的对象，这个对象池的最大长度是50。

8：Looper死循环为什么不会导致应用卡死?
    卡死就是ANR，产生的原因有2个：
    1、在5s内没有响应输入的事件(例如按键，触摸等)，2、BroadcastReceiver在10s内没有执行完毕。
    事实上我们所有的Activity和Service都是运行在loop()函数中，以消息的方式存在，所以在没有消息产生的时候，looper会被block(阻塞)，主线程会进入休眠，一旦有输入事件或者Looper添加消息的操作后主线程就会被唤醒，从而对事件进行响应，所以不会导致ANR
    简单来说looper的阻塞表明没有事件输入，而ANR是由于有事件没响应导致，所以looper的死循环并不会导致应用卡死。


Crash监控:
    JavaCrash:
        会走UncaughtExceptionHandler.uncaughtException
        Thread.setDefaultUncaughtExceptionHandler 该方法来设置线程的默认异常处理器.
    NDK Crash
        一类crash信号，在程序接收到此类信号时，缺省操作是将崩溃的现场信息记录到核心文件，然后终止进程。
            SIGSEGV 内存引用无效。
            SIGBUS 访问内存对象的未定义部分。
            SIGFPE 算术运算错误，除以零。
            SIGILL 非法指令，如执行垃圾或特权指令
            SIGSYS 糟糕的系统调用
            SIGXCPU 超过CPU时间限制。
            SIGXFSZ 文件大小限制。 

框架源码：
Glid: 
    with: 获取requestManager （onStart/onStop/onDestroy）
         getRetriever(activity)[Glide.get(context)] .get(activity)[作用域处理]
            Application:
            a: Application 域对应的是 applicationManager，它是与RequestManagerRetriever 对象绑定的；
            b：在子线程调用 get(...) ，或者传入参数是 ApplicationContext & ServiceContext 时，对应的请求是Application域。
            Fragment/../.:
            1.supportFragmentGet()->从FragmentManager中获取SupportRequestManagerFragment,获取RequestManager,初次获取实例化，再则从中读取
                SupportRequestManagerFragment:
                    a.findFragmentByTag(FRAGMENT_TAG)
                    b.pendingRequestManagerFragments.get(fm) 临时记录
                    c.实例化Fragment
                        1.创建对象
                        2.pendingRequestManagerFragments.set(fm) 临时记录
                        3.Fragment提交事务
                        4.post一个消息（ID_REMOVE_FRAGMENT_MANAGER） 移除pendingRequestManagerFragments临时记录。commitAllowingStateLoss()异步，防止重复创建
                SupportRequestManagerFragment创建含有一个Lifecycled对象，requestManager实例化时传入。当 Fragment 的生命周期变化时，就是通过这个Lifecycle对象将事件分发到RequestManager

        1.创建一个Fragment,通过ActivityFragmentLifecycle接口监听生命周期做相应的操作。
        （以确保优先处理前台可见的Activity/Fragment，提高资源利用率，在有必要时释放资源以避免在应用在后台时被杀死，提高稳定性）
        2.生命周期作用域（application，activity/fragment）
            application：子线程、serverContent、application
    
    load: RequestBuilder这是一个通用请求构建类，可以处理通用资源类型的设置选项和启动负载

    into: ViewTarget
        1.获取getScaleType clone配置 克隆（原型设计模式）
        2.into重载获取ImageViewTarget
            glideContext.buildImageViewTarget -> imageViewTargetFactory.buildTarget (工厂模式) -> DrawableImageViewTarget/BitmapImageViewTarget
                DrawableImageViewTarget继承ImageViewTarget重写的setResource函数，显示Drawable图片
        3.重载的into: 为Target构建request请求 -> RequestManager执行请求
            构建request: SingleRequest.obtain(...)
            RequestManager执行(synchronized): requestTracker.runRequest(request)
        ->request.begin() ->大小准备好 [onSizeReady() -> engine.load()]
        ->engine.load():
            1.获取请求key (宽高，类型，配置等)
            2.检查ActiveResources -> LruResourceCache
            3.检查job缓存
            4.否则EngineJob.start开启一个新的请求任务执行
        ->EngineJob.start: 获取线程池 执行任务
            a.是否配置资源缓存策略，否则只能从缓存中获取(ResourceCacheGenerator/DataCacheGenerator)
            b.SourceGenerator()
                获取loadData   ->buildLoadData(含有HttpUrlFetcher)
                ->loadData: loadDataWithRedirects()取得InputStream
                ->loadDataWithRedirects: HttpURLConnection作Glide底层网络请求,返回一个输入流后通过onDataReady回调出去
            C.decodeFromData(): 先构建LoadPath, 然后创建InputStreamRewinder类型的DataRewinder, 最终将数据解析的操作放到了LoadPath.load方法中
                1.deResource 将源数据解析成资源（源数据: InputStream， 中间产物:Bitmap）
                2.调用 DecodeCallback.onResourceDecoded 处理资源
                    a.对资源进行了转换操作。比如 Fit_Center,CenterCrop, 在请求的时候配置
                    b.构建磁盘缓存的key
                3.调用 ResourceTranscoder.transcode 将资源转为目标资源（目标资源类型: Drawable）
            d.notifyEncodeAndRelease:
                1.notifyComplete() 通知调用层数据已经装备好了
                2.deferredEncodeManager.encode 将资源磁盘缓存 (如果配置了)
                3.onEncodeComplete（） 完成
        ->EngineJob.onResourceReady:通知上层任务完成,回调ImageViewTarget用于展示数据。

    缓存： 先判断是否使用
        活动缓存    ->    LRU内存缓存（弱应用）     ->    LRU磁盘缓存
        1.活动缓存中获取：  （）
        2.内存缓存获取：添加到活动缓存，清理缓存数据
        3.网络获取：储存到内存缓存，展示数据

        磁盘缓存：
            内存缓存获取不到开启线程读取->根据Key去获取磁盘文件，存储